import java.awt.Point;

/**
 * SudokuGrid.
 *
 * TODO 4: FIll in your names and student IDs:
 *
 * Luca Bosch
 * @id ID
 * Sylvi Deng
 * 2252953
 */
public class SudokuGrid {
    private static final int SIZE = 9;
    private static final int BOX = 3;
    private static final int DIGIT_RANGE = 9;

    private int[][] grid;

    public SudokuGrid() {
        grid = new int[SIZE][SIZE];
    }

    /**
     * Creates a deep copy of this grid.
     *
     * @return a new SudokuGrid containing the same values
     */
    public SudokuGrid copy() {
        SudokuGrid copy = new SudokuGrid();
        for (int r = 0; r < SIZE; r++) {
            for (int c = 0; c < SIZE; c++) {
                copy.grid[r][c] = grid[r][c];
            }
        }
        return copy;
    }

    /**
     * Finds the first empty cell in reading order.
     *
     * @return a Point with the row and column of the empty cell, or null if none
     */
    public Point findEmptyCell() {
        for (int r = 0; r < SIZE; r++) {
            for (int c = 0; c < SIZE; c++) {
                if (grid[r][c] == 0) {
                    return new Point(r, c);
                }
            }
        }
        return null;
    }

    /**
     * Prints the grid using the required ASCII layout.
     */
    public void print() {
        System.out.println("+-----------------+");
        for (int r = 0; r < SIZE; r++) {
            System.out.print("|");
            for (int c = 0; c < SIZE; c++) {
                int value = grid[r][c];
                char symbol;
                if (value == 0) {
                    symbol = ' ';
                } else {
                    symbol = (char) ('0' + value);
                }
                System.out.print(symbol);
                if (c % BOX == BOX - 1) {
                    System.out.print("|");
                } else {
                    System.out.print(" ");
                }
            }
            System.out.println();
            if (r % BOX == BOX - 1) {
                System.out.println("+-----------------+");
            }
        }
    }

    /**
     * Fills a cell with the provided digit.
     *
     * @param r the row index
     * @param c the column index
     * @param d the digit to place (0 clears the cell)
     */
    public void fillCell(int r, int c, int d) {
        grid[r][c] = d;
    }

    /**
     * Determines whether placing a digit causes a conflict.
     *
     * @param r the row index
     * @param c the column index
     * @param d the digit to test
     * @return true if a conflict occurs, false otherwise
     */
    public boolean givesConflict(int r, int c, int d) {
        if (d == 0) {
            return false;
        }
        if (d < 1 || d > DIGIT_RANGE) {
            return true;
        }
        if (rowConflict(r, d)) {
            return true;
        }
        if (colConflict(c, d)) {
            return true;
        }
        if (boxConflict(r, c, d)) {
            return true;
        }
        return false;
    }

    private boolean rowConflict(int r, int d) {
        for (int c = 0; c < SIZE; c++) {
            if (grid[r][c] == d) {
                return true;
            }
        }
        return false;
    }

    private boolean colConflict(int c, int d) {
        for (int r = 0; r < SIZE; r++) {
            if (grid[r][c] == d) {
                return true;
            }
        }
        return false;
    }

    private boolean boxConflict(int r, int c, int d) {
        int startRow = (r / BOX) * BOX;
        int startCol = (c / BOX) * BOX;
        for (int row = startRow; row < startRow + BOX; row++) {
            for (int col = startCol; col < startCol + BOX; col++) {
                if (grid[row][col] == d) {
                    return true;
                }
            }
        }
        return false;
    }

    /**
     * Checks whether the current grid has no conflicts while ignoring empty cells.
     *
     * @return true if the grid is conflict free, false otherwise
     */
    boolean isValid() {
        for (int r = 0; r < SIZE; r++) {
            boolean[] seen = new boolean[DIGIT_RANGE + 1];
            for (int c = 0; c < SIZE; c++) {
                int value = grid[r][c];
                if (value == 0) {
                    continue;
                }
                if (seen[value]) {
                    return false;
                }
                seen[value] = true;
            }
        }
        for (int c = 0; c < SIZE; c++) {
            boolean[] seen = new boolean[DIGIT_RANGE + 1];
            for (int r = 0; r < SIZE; r++) {
                int value = grid[r][c];
                if (value == 0) {
                    continue;
                }
                if (seen[value]) {
                    return false;
                }
                seen[value] = true;
            }
        }
        for (int startRow = 0; startRow < SIZE; startRow += BOX) {
            for (int startCol = 0; startCol < SIZE; startCol += BOX) {
                boolean[] seen = new boolean[DIGIT_RANGE + 1];
                for (int r = startRow; r < startRow + BOX; r++) {
                    for (int c = startCol; c < startCol + BOX; c++) {
                        int value = grid[r][c];
                        if (value == 0) {
                            continue;
                        }
                        if (seen[value]) {
                            return false;
                        }
                        seen[value] = true;
                    }
                }
            }
        }
        return true;
    }
}
